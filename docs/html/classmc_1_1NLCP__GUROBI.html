<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>CRONOS: mc::NLCP_GUROBI&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CRONOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmc_1_1NLCP__GUROBI.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmc_1_1NLCP__GUROBI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mc::NLCP_GUROBI&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ class for nonlinear constraint projection using complete search.  
 <a href="classmc_1_1NLCP__GUROBI.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nlcp__gurobi_8hpp_source.html">nlcp_gurobi.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mc::NLCP_GUROBI&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmc_1_1NLCP__GUROBI__inherit__graph.png" border="0" usemap="#mc_1_1NLCP__GUROBI_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mc_1_1NLCP__GUROBI_3_01T_01_4_inherit__map" id="mc_1_1NLCP__GUROBI_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="classmc_1_1NLGO__GUROBI.html" title="C++ class for global optimization of NLP and MINLP using complete search. " alt="" coords="5,145,181,175"/><area shape="rect" id="node4" href="classmc_1_1AEBND.html" title="mc::AEBND\&lt; T, CModel\l\&lt; T \&gt;, CVar\&lt; T \&gt; \&gt;" alt="" coords="205,137,373,183"/><area shape="rect" id="node6" href="classmc_1_1AEBND.html" title="C++ class computing enclosures of the solution set of parametric AEs. " alt="" coords="212,6,367,53"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mc::NLCP_GUROBI&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmc_1_1NLCP__GUROBI__coll__graph.png" border="0" usemap="#mc_1_1NLCP__GUROBI_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="mc_1_1NLCP__GUROBI_3_01T_01_4_coll__map" id="mc_1_1NLCP__GUROBI_3_01T_01_4_coll__map">
<area shape="rect" id="node2" href="classmc_1_1NLGO__GUROBI.html" title="C++ class for global optimization of NLP and MINLP using complete search. " alt="" coords="953,97,1129,127"/><area shape="rect" id="node4" href="structmc_1_1NLGO__GUROBI_1_1Stats.html" title="Structure holding current statistics. " alt="" coords="655,5,820,51"/><area shape="rect" id="node6" href="structmc_1_1NLGO__GUROBI_1_1Options.html" title="Structure holding options for NLGO_GUROBI. " alt="" coords="655,133,820,179"/><area shape="rect" id="node18" href="structmc_1_1NLCP__GUROBI_1_1Options.html" title="NLCP_GUROBI options. " alt="" coords="960,153,1123,199"/><area shape="rect" id="node8" href="structmc_1_1NLPSLV__IPOPT_1_1Options.html" title="Structure holding the NLP solver options. " alt="" coords="257,141,455,171"/><area shape="rect" id="node11" href="classmc_1_1AEBND.html" title="mc::AEBND\&lt; T, CModel\l\&lt; T \&gt;, CVar\&lt; T \&gt; \&gt;" alt="" coords="653,209,821,255"/><area shape="rect" id="node13" href="structmc_1_1AEBND_1_1Options.html" title="Integrator options. " alt="" coords="5,227,160,274"/><area shape="rect" id="node15" href="classmc_1_1AEBND.html" title="C++ class computing enclosures of the solution set of parametric AEs. " alt="" coords="279,271,433,318"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmc_1_1NLCP__GUROBI_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmc_1_1NLCP__GUROBI.html" title="C++ class for nonlinear constraint projection using complete search. ">NLCP_GUROBI</a> options.  <a href="structmc_1_1NLCP__GUROBI_1_1Options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32b8e97baefb67265990268e0767888d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32b8e97baefb67265990268e0767888d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a32b8e97baefb67265990268e0767888d">solve</a> (const T *P, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:a32b8e97baefb67265990268e0767888d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve constraint projection problem &ndash; return value is a measure of boundary volume. <br/></td></tr>
<tr class="separator:a32b8e97baefb67265990268e0767888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6ec4771bd2a927684289fff8068c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91a6ec4771bd2a927684289fff8068c7"></a>
SetInv&lt; CVar&lt; T &gt; &gt;::<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a91a6ec4771bd2a927684289fff8068c7">assess</a> (const T *P, const unsigned *tvar=0, const unsigned refine=0, const bool reset=true)</td></tr>
<tr class="memdesc:a91a6ec4771bd2a927684289fff8068c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve relaxed optimization model using GUROBI within variable range P and for variable types tvar &ndash; return value is SetInv&lt;CVar&lt;T&gt;&gt;::STATUS. <br/></td></tr>
<tr class="separator:a91a6ec4771bd2a927684289fff8068c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770eb19298167471c87548a20ec9518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7770eb19298167471c87548a20ec9518"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a7770eb19298167471c87548a20ec9518">output_nodes</a> (std::ostream &amp;os_open, const unsigned int DPREC=6) const </td></tr>
<tr class="memdesc:a7770eb19298167471c87548a20ec9518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all open (set-boundary) nodes to os_open - Number of significant digits is set via DPREC (default=6) <br/></td></tr>
<tr class="separator:a7770eb19298167471c87548a20ec9518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5888f54eea3b9dc756764823428d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5888f54eea3b9dc756764823428d0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#acc5888f54eea3b9dc756764823428d0a">output_nodes</a> (std::ostream &amp;os_open, const double NSAMP, const unsigned DPREC) const </td></tr>
<tr class="memdesc:acc5888f54eea3b9dc756764823428d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all open (set-boundary) nodes to os_open - Number of significant digits is set via DPREC (default=6) <br/></td></tr>
<tr class="separator:acc5888f54eea3b9dc756764823428d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ga70a5d8f4d1be474dbd19875290b1f514"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a> </td></tr>
<tr class="memdesc:ga70a5d8f4d1be474dbd19875290b1f514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver status. <br/></td></tr>
<tr class="separator:ga70a5d8f4d1be474dbd19875290b1f514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a52bc42f2bde24c7e8b4f404e9fea1ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52bc42f2bde24c7e8b4f404e9fea1ae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a52bc42f2bde24c7e8b4f404e9fea1ae7">_set_SetInvoptions</a> () const </td></tr>
<tr class="memdesc:a52bc42f2bde24c7e8b4f404e9fea1ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set options of SetInv solver. <br/></td></tr>
<tr class="separator:a52bc42f2bde24c7e8b4f404e9fea1ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10667536c56d1d205b0d1d234f39d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0e10667536c56d1d205b0d1d234f39d"></a>
SetInv&lt; CVar&lt; T &gt; &gt;::<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#aa0e10667536c56d1d205b0d1d234f39d">assess</a> (SetInvNode&lt; CVar&lt; T &gt;&gt; *node)</td></tr>
<tr class="memdesc:aa0e10667536c56d1d205b0d1d234f39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-function to subproblem assessment in SetInv. <br/></td></tr>
<tr class="separator:aa0e10667536c56d1d205b0d1d234f39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661638f515d10f1f145ef09c941ca5d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a661638f515d10f1f145ef09c941ca5d8"></a>
SetInv&lt; CVar&lt; T &gt; &gt;::<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a661638f515d10f1f145ef09c941ca5d8">_subproblem_assess</a> (T *P)</td></tr>
<tr class="memdesc:a661638f515d10f1f145ef09c941ca5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subproblem for node assessment. <br/></td></tr>
<tr class="separator:a661638f515d10f1f145ef09c941ca5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bbe392acd162fa9de4ccbc1243d79e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18bbe392acd162fa9de4ccbc1243d79e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a18bbe392acd162fa9de4ccbc1243d79e">_subproblem_project</a> (CVar&lt; T &gt; *CVP, std::set&lt; unsigned &gt; &amp;depend)</td></tr>
<tr class="memdesc:a18bbe392acd162fa9de4ccbc1243d79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subproblem for node projection (reduced space) <br/></td></tr>
<tr class="separator:a18bbe392acd162fa9de4ccbc1243d79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b602c40a53098be18902189266e8ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b602c40a53098be18902189266e8ed"></a>
SetInv&lt; CVar&lt; T &gt; &gt;::<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#ac3b602c40a53098be18902189266e8ed">_assess</a> (T *P, unsigned &amp;nred, const unsigned *tvar=0, const double *inc=0, const bool reset=true, const bool feastest=false)</td></tr>
<tr class="memdesc:ac3b602c40a53098be18902189266e8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform iterative bound contraction from relaxed model with inclusion test at each iteration. <br/></td></tr>
<tr class="separator:ac3b602c40a53098be18902189266e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c15b46327b6b5ba72a30d62a7f4304"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55c15b46327b6b5ba72a30d62a7f4304"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a55c15b46327b6b5ba72a30d62a7f4304"><td class="memTemplItemLeft" align="right" valign="top">SetInv&lt; CVar&lt; T &gt; &gt;::<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a55c15b46327b6b5ba72a30d62a7f4304">_inclusion_test</a> (const std::vector&lt; U &gt; &amp;C) const </td></tr>
<tr class="memdesc:a55c15b46327b6b5ba72a30d62a7f4304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform inclusion test based on constraint Chebysev models (if available) <br/></td></tr>
<tr class="separator:a55c15b46327b6b5ba72a30d62a7f4304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8557e41b81498589f2d40a1453346865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8557e41b81498589f2d40a1453346865"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#a8557e41b81498589f2d40a1453346865">volume</a> (const std::vector&lt; CVar&lt; T &gt;&gt; &amp;CVP) const </td></tr>
<tr class="memdesc:a8557e41b81498589f2d40a1453346865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute partition volume. <br/></td></tr>
<tr class="separator:a8557e41b81498589f2d40a1453346865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a93ecc0487ad0153c91bdc30f9f6a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0a93ecc0487ad0153c91bdc30f9f6a1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLCP__GUROBI.html#ac0a93ecc0487ad0153c91bdc30f9f6a1">length</a> (const std::vector&lt; CVar&lt; T &gt;&gt; &amp;CVP) const </td></tr>
<tr class="memdesc:ac0a93ecc0487ad0153c91bdc30f9f6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute partition length. <br/></td></tr>
<tr class="separator:ac0a93ecc0487ad0153c91bdc30f9f6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fa190ca7e26eb2970f33387a71ccab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37fa190ca7e26eb2970f33387a71ccab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#ga37fa190ca7e26eb2970f33387a71ccab">setup</a> ()</td></tr>
<tr class="memdesc:ga37fa190ca7e26eb2970f33387a71ccab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup DAG for cost and constraint evaluation. <br/></td></tr>
<tr class="separator:ga37fa190ca7e26eb2970f33387a71ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d9f220dbe8fef3dacf51efb7d8454d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2d9f220dbe8fef3dacf51efb7d8454d"></a>
Ipopt::ApplicationReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gad2d9f220dbe8fef3dacf51efb7d8454d">local</a> (const T *P, const double *p0=0, const bool reset=true)</td></tr>
<tr class="memdesc:gad2d9f220dbe8fef3dacf51efb7d8454d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve (continuous) optimization model to local optimality using IPOPT in variable range P and from initial point p0 &ndash; return value is IPOPT status. <br/></td></tr>
<tr class="separator:gad2d9f220dbe8fef3dacf51efb7d8454d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3062220809783ea9eebfbd95b9b801e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3062220809783ea9eebfbd95b9b801e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gaf3062220809783ea9eebfbd95b9b801e">relax</a> (const T *P, const unsigned *tvar=0, const unsigned refine=0, const bool reset=true, const bool feastest=false)</td></tr>
<tr class="memdesc:gaf3062220809783ea9eebfbd95b9b801e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve relaxed optimization model (or relaxed feasibility model if feastest is true) using GUROBI within variable range P and for variable types tvar &ndash; return value is <a href="http://www.gurobi.com/documentation/6.0/refman/optimization_status_codes.html">GUROBI status</a> <br/></td></tr>
<tr class="separator:gaf3062220809783ea9eebfbd95b9b801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef8c3ff698f5c7708420180a8ce2516"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ef8c3ff698f5c7708420180a8ce2516"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#ga6ef8c3ff698f5c7708420180a8ce2516">contract</a> (T *P, unsigned &amp;nred, const unsigned *tvar=0, const double *inc=0, const bool reset=true, const bool feastest=false)</td></tr>
<tr class="memdesc:ga6ef8c3ff698f5c7708420180a8ce2516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve bound contraction problems from relaxed model using GUROBI, starting with variable range P, for variable types tvar and incumbent value inc (or constraint backoff if feastest is true), and using the options specified in <a class="el" href="structmc_1_1NLGO__GUROBI_1_1Options.html#afd4b50fac3889f2a2198ee624f98dc12" title="Maximum number of domain reduction rounds. ">NLGO_GUROBI::Options::DOMREDMAX</a> and <a class="el" href="structmc_1_1NLGO__GUROBI_1_1Options.html#a244f64a02935bd78cce7035043d7dc66" title="Threshold for repeating domain reduction (minimum domain reduction ratio) ">NLGO_GUROBI::Options::DOMREDTHRES</a> &ndash; return is <a href="http://www.gurobi.com/documentation/6.0/refman/optimization_status_codes.html">GUROBI status</a>, updated variable bounds P, and number of iterative refinements nred <br/></td></tr>
<tr class="separator:ga6ef8c3ff698f5c7708420180a8ce2516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ae58ead2ba5e075d16ca7f85a4c747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0ae58ead2ba5e075d16ca7f85a4c747"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gab0ae58ead2ba5e075d16ca7f85a4c747">contract</a> (const T *P, const unsigned ip, const bool uplo, const unsigned *tvar=0, const double *inc=0, const bool reset=true, const bool feastest=false)</td></tr>
<tr class="memdesc:gab0ae58ead2ba5e075d16ca7f85a4c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve bound contraction problem for lower/upper component ip from relaxed model using GUROBI, starting with variable range P and incumbent value inc (or constraint backoff if feastest is true) &ndash; return is <a href="http://www.gurobi.com/documentation/6.0/refman/optimization_status_codes.html">GUROBI status</a> <br/></td></tr>
<tr class="separator:gab0ae58ead2ba5e075d16ca7f85a4c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67eaa2ead046f3359d0bce81b991044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad67eaa2ead046f3359d0bce81b991044"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gad67eaa2ead046f3359d0bce81b991044">solve</a> (const T *P, const unsigned *tvar=0, const double *p0=0, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:gad67eaa2ead046f3359d0bce81b991044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve optimization model to global optimality within variable range P and for variable types tvar &ndash; return value is <a href="http://www.gurobi.com/documentation/6.0/refman/optimization_status_codes.html">GUROBI status</a> <br/></td></tr>
<tr class="separator:gad67eaa2ead046f3359d0bce81b991044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae196cd4e1c2ac9ec2f97b5acf8700fe7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae196cd4e1c2ac9ec2f97b5acf8700fe7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gae196cd4e1c2ac9ec2f97b5acf8700fe7">get_variable</a> (const FFVar &amp;X) const </td></tr>
<tr class="memdesc:gae196cd4e1c2ac9ec2f97b5acf8700fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of DAG variable X after last LP optimization. <br/></td></tr>
<tr class="separator:gae196cd4e1c2ac9ec2f97b5acf8700fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5893e7bef6fcf1f37a3895f368eb310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5893e7bef6fcf1f37a3895f368eb310"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gad5893e7bef6fcf1f37a3895f368eb310">get_objective</a> () const </td></tr>
<tr class="memdesc:gad5893e7bef6fcf1f37a3895f368eb310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimal cost value after last LP optimization. <br/></td></tr>
<tr class="separator:gad5893e7bef6fcf1f37a3895f368eb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5b0de5e82930e6eef952b3648ada2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e5b0de5e82930e6eef952b3648ada2f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#ga3e5b0de5e82930e6eef952b3648ada2f">get_status</a> () const </td></tr>
<tr class="memdesc:ga3e5b0de5e82930e6eef952b3648ada2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status after last LP optimization. <br/></td></tr>
<tr class="separator:ga3e5b0de5e82930e6eef952b3648ada2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9112aaa1a852355f5e0554929189efd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9112aaa1a852355f5e0554929189efd0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#ga9112aaa1a852355f5e0554929189efd0">optimal_status</a> () const </td></tr>
<tr class="memdesc:ga9112aaa1a852355f5e0554929189efd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check optimal status after last LP optimization. <br/></td></tr>
<tr class="separator:ga9112aaa1a852355f5e0554929189efd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3c08c3c8f63a75645d768edd5ae6bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf3c08c3c8f63a75645d768edd5ae6bc"></a>
const GRBModel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gadf3c08c3c8f63a75645d768edd5ae6bc">get_relaxed_model</a> () const </td></tr>
<tr class="memdesc:gadf3c08c3c8f63a75645d768edd5ae6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to last LP optimization model and solution. <br/></td></tr>
<tr class="separator:gadf3c08c3c8f63a75645d768edd5ae6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32ed29bced09049c8559adc29745639"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae32ed29bced09049c8559adc29745639"></a>
const NLPSLV_IPOPT::SOLUTION &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NLGO__GUROBI.html#gae32ed29bced09049c8559adc29745639">get_local_solution</a> () const </td></tr>
<tr class="memdesc:gae32ed29bced09049c8559adc29745639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local solution information after last NLP optimization. <br/></td></tr>
<tr class="separator:gae32ed29bced09049c8559adc29745639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560227335f36f27bcefa7f518303b826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a560227335f36f27bcefa7f518303b826"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a560227335f36f27bcefa7f518303b826">_set_polrelax</a> (const T *P, const unsigned *tvar, const bool feastest=false)</td></tr>
<tr class="memdesc:a560227335f36f27bcefa7f518303b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set model polyhedral relaxation. <br/></td></tr>
<tr class="separator:a560227335f36f27bcefa7f518303b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca528396fb37d6fae4d5171f625efbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ca528396fb37d6fae4d5171f625efbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a5ca528396fb37d6fae4d5171f625efbf">_refine_polrelax</a> (const T *P, const unsigned *tvar, const bool feastest=false)</td></tr>
<tr class="memdesc:a5ca528396fb37d6fae4d5171f625efbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine model polyhedral relaxation by adding breakpoints. <br/></td></tr>
<tr class="separator:a5ca528396fb37d6fae4d5171f625efbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91d22ef77705db69df346bd1d81ca06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad91d22ef77705db69df346bd1d81ca06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#ad91d22ef77705db69df346bd1d81ca06">_update_polrelax</a> (const T *P, const unsigned *tvar, const bool feastest=false)</td></tr>
<tr class="memdesc:ad91d22ef77705db69df346bd1d81ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update model polyhedral relaxation (bounds and types) <br/></td></tr>
<tr class="separator:ad91d22ef77705db69df346bd1d81ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e411c290843599ef70d11ab86f48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a5e411c290843599ef70d11ab86f48c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a0a5e411c290843599ef70d11ab86f48c">_set_LPrelax</a> (const bool feastest=false)</td></tr>
<tr class="memdesc:a0a5e411c290843599ef70d11ab86f48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set relaxed objective in LP model. <br/></td></tr>
<tr class="separator:a0a5e411c290843599ef70d11ab86f48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea657a04f88dba4be7c61140ebc6811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea657a04f88dba4be7c61140ebc6811"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a2ea657a04f88dba4be7c61140ebc6811">_set_LPcontract</a> (const unsigned ip, const bool uplo, const double *inc, const bool feastest=false)</td></tr>
<tr class="memdesc:a2ea657a04f88dba4be7c61140ebc6811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameter bound contracting objective in LP model. <br/></td></tr>
<tr class="separator:a2ea657a04f88dba4be7c61140ebc6811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96998f2c646feaaf17d49387b92e7b84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96998f2c646feaaf17d49387b92e7b84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a96998f2c646feaaf17d49387b92e7b84">_solve_LPmodel</a> ()</td></tr>
<tr class="memdesc:a96998f2c646feaaf17d49387b92e7b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve LP model. <br/></td></tr>
<tr class="separator:a96998f2c646feaaf17d49387b92e7b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe01e103d09fa639321efbbab5b003"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeffe01e103d09fa639321efbbab5b003"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#aeffe01e103d09fa639321efbbab5b003">_contract</a> (T *P, const unsigned *tvar=0, const double *inc=0, const bool reset=true, const bool feastest=false)</td></tr>
<tr class="memdesc:aeffe01e103d09fa639321efbbab5b003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tighten parameter bounds P for NLP model relaxation and incumbent value inc (or constraint backoff is feastest is true) &ndash; return value is <a href="http://www.gurobi.com/documentation/6.0/refman/optimization_status_codes.html">GUROBI status</a> <br/></td></tr>
<tr class="separator:aeffe01e103d09fa639321efbbab5b003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6437517944a014e46930402aa2d202"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c6437517944a014e46930402aa2d202"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a7c6437517944a014e46930402aa2d202">_get_variable</a> (const PolVar&lt; T &gt; &amp;X) const </td></tr>
<tr class="memdesc:a7c6437517944a014e46930402aa2d202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of PolImg variable X after last LP optimization. <br/></td></tr>
<tr class="separator:a7c6437517944a014e46930402aa2d202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38918adc2f0476ec0f19df608621bef3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38918adc2f0476ec0f19df608621bef3"></a>
<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#ga38918adc2f0476ec0f19df608621bef3">setup</a> (std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:ga38918adc2f0476ec0f19df608621bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform block decomposition of AE system. <br/></td></tr>
<tr class="separator:ga38918adc2f0476ec0f19df608621bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46438d1546dc96ff610a9f3e1a5589f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#ga46438d1546dc96ff610a9f3e1a5589f8">solve</a> (const T *Ip, T *Ix, const T *Ix0=0, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:ga46438d1546dc96ff610a9f3e1a5589f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute interval enclosure of solution set of parametric AEs.  <a href="#ga46438d1546dc96ff610a9f3e1a5589f8">More...</a><br/></td></tr>
<tr class="separator:ga46438d1546dc96ff610a9f3e1a5589f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68037bda04291fe247c5a4320bda0c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#ga68037bda04291fe247c5a4320bda0c22">solve</a> (const CVar&lt; T &gt; *PMp, CVar&lt; T &gt; *PMx, const T *Ix0, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:ga68037bda04291fe247c5a4320bda0c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute polynomial model of solution set of parametric AEs.  <a href="#ga68037bda04291fe247c5a4320bda0c22">More...</a><br/></td></tr>
<tr class="separator:ga68037bda04291fe247c5a4320bda0c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5add42bde95ef8c8863eb1f3c6bf20ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#ga5add42bde95ef8c8863eb1f3c6bf20ce">solve</a> (const CVar&lt; T &gt; *PMp, CVar&lt; T &gt; *PMx, const CVar&lt; T &gt; *PMx0=0, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:ga5add42bde95ef8c8863eb1f3c6bf20ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute polynomial model of solution set of parametric AEs.  <a href="#ga5add42bde95ef8c8863eb1f3c6bf20ce">More...</a><br/></td></tr>
<tr class="separator:ga5add42bde95ef8c8863eb1f3c6bf20ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee83a76a63e7256899983993a5a73ffa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee83a76a63e7256899983993a5a73ffa"></a>
<a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AEBND.html#gaee83a76a63e7256899983993a5a73ffa">solve</a> (FFVar *X, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:gaee83a76a63e7256899983993a5a73ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symbolic solution (DAG) of parametric AEs. <br/></td></tr>
<tr class="separator:gaee83a76a63e7256899983993a5a73ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af9084ac1ab53756f4c4aabbb702eca62"><td class="memTemplParams" colspan="2"><a class="anchor" id="af9084ac1ab53756f4c4aabbb702eca62"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:af9084ac1ab53756f4c4aabbb702eca62"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#af9084ac1ab53756f4c4aabbb702eca62">_dH</a> (const U &amp;X, const U &amp;Y)</td></tr>
<tr class="memdesc:af9084ac1ab53756f4c4aabbb702eca62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function computing Hausdorff distance between intervals. <br/></td></tr>
<tr class="separator:af9084ac1ab53756f4c4aabbb702eca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc51157ba8ced6b6aa4da877da867d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60bc51157ba8ced6b6aa4da877da867d"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a60bc51157ba8ced6b6aa4da877da867d"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a60bc51157ba8ced6b6aa4da877da867d">_reducrel</a> (const unsigned n, const U *Xred, const U *X)</td></tr>
<tr class="memdesc:a60bc51157ba8ced6b6aa4da877da867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function computing Hausdorff distance between interval vectors. <br/></td></tr>
<tr class="separator:a60bc51157ba8ced6b6aa4da877da867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a26f0acd03bfd14e1c957adb02b485120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f0acd03bfd14e1c957adb02b485120"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a26f0acd03bfd14e1c957adb02b485120">_nvar</a></td></tr>
<tr class="memdesc:a26f0acd03bfd14e1c957adb02b485120"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of variables in problem (both independent &amp; dependent) <br/></td></tr>
<tr class="separator:a26f0acd03bfd14e1c957adb02b485120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ddd90d9e7b97e3808d5bee769d860c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74ddd90d9e7b97e3808d5bee769d860c"></a>
std::vector&lt; FFVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a74ddd90d9e7b97e3808d5bee769d860c">_var</a></td></tr>
<tr class="memdesc:a74ddd90d9e7b97e3808d5bee769d860c"><td class="mdescLeft">&#160;</td><td class="mdescRight">decision variables (both independent &amp; dependent) <br/></td></tr>
<tr class="separator:a74ddd90d9e7b97e3808d5bee769d860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa078dbaeb01202350cfa8106cd0d2df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa078dbaeb01202350cfa8106cd0d2df"></a>
std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#aaa078dbaeb01202350cfa8106cd0d2df">_tvar</a></td></tr>
<tr class="memdesc:aaa078dbaeb01202350cfa8106cd0d2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable types in problem (both independent &amp; dependent) <br/></td></tr>
<tr class="separator:aaa078dbaeb01202350cfa8106cd0d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee0b0d873d3ec2e515fa2f4e60f48ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afee0b0d873d3ec2e515fa2f4e60f48ad"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#afee0b0d873d3ec2e515fa2f4e60f48ad">_nctr</a></td></tr>
<tr class="memdesc:afee0b0d873d3ec2e515fa2f4e60f48ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of constraints in problem <br/></td></tr>
<tr class="separator:afee0b0d873d3ec2e515fa2f4e60f48ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62083b16d1af6865af9b6d693abf5af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62083b16d1af6865af9b6d693abf5af9"></a>
std::tuple&lt; std::vector&lt; t_CTR &gt;<br class="typebreak"/>
, std::vector&lt; FFVar &gt;<br class="typebreak"/>
, std::vector&lt; FFVar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a62083b16d1af6865af9b6d693abf5af9">_ctr</a></td></tr>
<tr class="memdesc:a62083b16d1af6865af9b6d693abf5af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constraints (types, constraint variables, constraint multipliers), including dependent equations <br/></td></tr>
<tr class="separator:a62083b16d1af6865af9b6d693abf5af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6df2e9f31f503a7c6f32699d72706e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d6df2e9f31f503a7c6f32699d72706e"></a>
std::list&lt; const FFOp * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a9d6df2e9f31f503a7c6f32699d72706e">_op_f</a></td></tr>
<tr class="memdesc:a9d6df2e9f31f503a7c6f32699d72706e"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of operations for objective evaluation <br/></td></tr>
<tr class="separator:a9d6df2e9f31f503a7c6f32699d72706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a66ffe2ad4c4d3ff5d8a66fa7c46ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a66ffe2ad4c4d3ff5d8a66fa7c46ed"></a>
std::vector&lt; std::list&lt; const <br class="typebreak"/>
FFOp * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#ac1a66ffe2ad4c4d3ff5d8a66fa7c46ed">_op_g</a></td></tr>
<tr class="memdesc:ac1a66ffe2ad4c4d3ff5d8a66fa7c46ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of lists of operations for constraint evaluation <br/></td></tr>
<tr class="separator:ac1a66ffe2ad4c4d3ff5d8a66fa7c46ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1bc598546c1eeaa04e1f0438507e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d1bc598546c1eeaa04e1f0438507e8a"></a>
std::list&lt; const FFOp * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a6d1bc598546c1eeaa04e1f0438507e8a">_op_dL</a></td></tr>
<tr class="memdesc:a6d1bc598546c1eeaa04e1f0438507e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of operations for Lagragian gradient evaluation <br/></td></tr>
<tr class="separator:a6d1bc598546c1eeaa04e1f0438507e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892daf8238ff232d01ed34dbdd08d73e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a892daf8238ff232d01ed34dbdd08d73e"></a>
PolImg&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a892daf8238ff232d01ed34dbdd08d73e">_POLenv</a></td></tr>
<tr class="memdesc:a892daf8238ff232d01ed34dbdd08d73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyhedral image environment. <br/></td></tr>
<tr class="separator:a892daf8238ff232d01ed34dbdd08d73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505de6fdc42bbd302a6ed6a2ba9b4706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a505de6fdc42bbd302a6ed6a2ba9b4706"></a>
std::vector&lt; PolVar&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a505de6fdc42bbd302a6ed6a2ba9b4706">_op_POLfg</a></td></tr>
<tr class="memdesc:a505de6fdc42bbd302a6ed6a2ba9b4706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage vector for function evaluation in polyhedral relaxation arithmetic. <br/></td></tr>
<tr class="separator:a505de6fdc42bbd302a6ed6a2ba9b4706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bbce37184ccbcc3e8a6f9e966c8dc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9bbce37184ccbcc3e8a6f9e966c8dc1"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#af9bbce37184ccbcc3e8a6f9e966c8dc1">_CMdim</a></td></tr>
<tr class="memdesc:af9bbce37184ccbcc3e8a6f9e966c8dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev model dimension. <br/></td></tr>
<tr class="separator:af9bbce37184ccbcc3e8a6f9e966c8dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3537090ff459b39e27aa078fa4bcb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f3537090ff459b39e27aa078fa4bcb6"></a>
std::set&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a7f3537090ff459b39e27aa078fa4bcb6">_CMexcl</a></td></tr>
<tr class="memdesc:a7f3537090ff459b39e27aa078fa4bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev excluded variables. <br/></td></tr>
<tr class="separator:a7f3537090ff459b39e27aa078fa4bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0132bb5fc4a2e481cbd23525fe7c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0132bb5fc4a2e481cbd23525fe7c27"></a>
CModel&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a2b0132bb5fc4a2e481cbd23525fe7c27">_CMenv</a></td></tr>
<tr class="memdesc:a2b0132bb5fc4a2e481cbd23525fe7c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev model environment. <br/></td></tr>
<tr class="separator:a2b0132bb5fc4a2e481cbd23525fe7c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc56603ea5d8c6a224935c18283456df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc56603ea5d8c6a224935c18283456df"></a>
std::vector&lt; CVar&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#adc56603ea5d8c6a224935c18283456df">_CMvar</a></td></tr>
<tr class="memdesc:adc56603ea5d8c6a224935c18283456df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev variables. <br/></td></tr>
<tr class="separator:adc56603ea5d8c6a224935c18283456df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84071d2dae186301d0dcab2568639b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf84071d2dae186301d0dcab2568639b"></a>
CVar&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#acf84071d2dae186301d0dcab2568639b">_CMobj</a></td></tr>
<tr class="memdesc:acf84071d2dae186301d0dcab2568639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev objective variable. <br/></td></tr>
<tr class="separator:acf84071d2dae186301d0dcab2568639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c2ce62055ccadba4c61cae691c6c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a2c2ce62055ccadba4c61cae691c6c5"></a>
std::vector&lt; CVar&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#a9a2c2ce62055ccadba4c61cae691c6c5">_CMctr</a></td></tr>
<tr class="memdesc:a9a2c2ce62055ccadba4c61cae691c6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev constraint variables. <br/></td></tr>
<tr class="separator:a9a2c2ce62055ccadba4c61cae691c6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af449c3ec0731843682af0f3a2cb99f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af449c3ec0731843682af0f3a2cb99f63"></a>
std::vector&lt; CVar&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmc_1_1NLGO__GUROBI.html#af449c3ec0731843682af0f3a2cb99f63">_op_CMfg</a></td></tr>
<tr class="memdesc:af449c3ec0731843682af0f3a2cb99f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage vector for function evaluation in Chebyshev arithmetic. <br/></td></tr>
<tr class="separator:af449c3ec0731843682af0f3a2cb99f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class mc::NLCP_GUROBI&lt; T &gt;</h3>

<p><a class="el" href="classmc_1_1NLCP__GUROBI.html" title="C++ class for nonlinear constraint projection using complete search. ">mc::NLCP_GUROBI</a> is a C++ class for constraint projection using complete search. Relaxations for the nonlinear or nonconvex participating terms are generated using MC++. Further details can be found at: <a class="el" href="page_NLCP_GUROBI.html">Nonlinear Constraint Projection using MC++ and GUROBI</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ga46438d1546dc96ff610a9f3e1a5589f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a> <a class="el" href="classmc_1_1AEBND.html">mc::AEBND</a>&lt; T, CModel&lt; T &gt; , CVar&lt; T &gt;  &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ix0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes an interval enclosure of the solution set of the parametric AEs:</p>
<ul>
<li>Ip [input] interval parameter set</li>
<li>Ix [output] interval state enclosure</li>
<li>Ix0 [input] a priori interval state bounds (default: NULL)</li>
<li>os [input] output stream (default: std::cout)</li>
</ul>
<p>The return value is the status. </p>

</div>
</div>
<a class="anchor" id="ga68037bda04291fe247c5a4320bda0c22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a> <a class="el" href="classmc_1_1AEBND.html">mc::AEBND</a>&lt; T, CModel&lt; T &gt; , CVar&lt; T &gt;  &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const CVar&lt; T &gt;  *&#160;</td>
          <td class="paramname"><em>PMp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CVar&lt; T &gt;  *&#160;</td>
          <td class="paramname"><em>PMx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ix0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes an interval enclosure of the solution set of the parametric AEs:</p>
<ul>
<li>PMp [input] polynomial model of parameter set</li>
<li>PMx [output] polynomial model of state enclosure</li>
<li>Ix0 [input] a priori interval state bounds (default: NULL)</li>
<li>os [input] output stream (default: std::cout)</li>
</ul>
<p>The return value is the status. </p>

</div>
</div>
<a class="anchor" id="ga5add42bde95ef8c8863eb1f3c6bf20ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__AEBND.html#ga70a5d8f4d1be474dbd19875290b1f514">STATUS</a> <a class="el" href="classmc_1_1AEBND.html">mc::AEBND</a>&lt; T, CModel&lt; T &gt; , CVar&lt; T &gt;  &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const CVar&lt; T &gt;  *&#160;</td>
          <td class="paramname"><em>PMp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CVar&lt; T &gt;  *&#160;</td>
          <td class="paramname"><em>PMx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CVar&lt; T &gt;  *&#160;</td>
          <td class="paramname"><em>PMx0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes an interval enclosure of the solution set of the parametric AEs:</p>
<ul>
<li>PMp [input] polynomial model of parameter set</li>
<li>PMx [output] polynomial model of state enclosure</li>
<li>PMx0 [input] a priori polynomial model of state bounds (default: NULL)</li>
<li>os [input] output stream (default: std::cout)</li>
</ul>
<p>The return value is the status. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/bchachua/Programs/Devel/MC++/CRONOS_1.0/src/<a class="el" href="nlcp__gurobi_8hpp_source.html">nlcp_gurobi.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mc</b></li><li class="navelem"><a class="el" href="classmc_1_1NLCP__GUROBI.html">NLCP_GUROBI</a></li>
    <li class="footer">Generated on Wed Oct 7 2015 20:40:15 for CRONOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
